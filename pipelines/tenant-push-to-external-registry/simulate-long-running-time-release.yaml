# # # apiVersion: tekton.dev/v1
# # # kind: Task
# # # metadata:
# # #   name: idle-final-task
# # # spec:
# # #   steps:
# # #     - name: wait
# # #       image: registry.access.redhat.com/ubi8/ubi-minimal
# # #       script: |
# # #         #!/bin/sh
# # #         echo "Trying to run a final task..."
# # #         sleep 30
# # #       resources:
# # #         requests:
# # #           memory: "2Ti"
# # #           cpu: "999"
# # # apiVersion: tekton.dev/v1
# # # kind: Task
# # # metadata:
# # #   name: idle-final-task
# # # spec:
# # #   params:
# # #     - name: enable-finalizer
# # #   steps:
# # #     - name: maybe-idle
# # #       image: registry.access.redhat.com/ubi8/ubi-minimal
# # #       script: |
# # #         sleep 10
# # # apiVersion: tekton.dev/v1
# # # kind: Task
# # # metadata:
# # #   name: simulate-pending-2
# # # spec:
# # #   steps:
# # #     - name: wait-forever
# # #       image: busybox:latest
# # #       resources:
# # #         requests:
# # #           memory: "500Gi"
# # #           cpu: "100"
# # #       script: |
# # #         #!/bin/sh
# # #         sleep 9999
# # ---
# # apiVersion: tekton.dev/v1
# # kind: Pipeline
# # metadata:
# #   name: simulate-long-running-time-release
# #   annotations:
# #     tekton.dev/tags: release
# #   labels:
# #     appstudio.openshift.io/release-pipeline: "true"
# # spec:
# #   description: Minimal pipeline for testing ReleasePlan integration
# #   params:
# #     - name: enable-finalizer
# #       type: string
# #       default: "true"
# #     - name: enable-wait
# #       type: string
# #       default: "true"
# #   workspaces:
# #     - name: release-workspace
# #   results:
# #     - name: TEST_OUTPUT
# #       value: "$(tasks.test-output.results.TEST_OUTPUT)"
# #   tasks:
# #     - name: hello
# #       taskSpec:
# #         steps:
# #           - name: say-hello
# #             image: registry.access.redhat.com/ubi8/ubi-minimal
# #             script: |
# #               #!/bin/sh
# #               echo "Hello from a minimal pipeline!"

# #     - name: goodbye
# #       runAfter:
# #         - hello
# #       taskSpec:
# #         steps:
# #           - name: say-goodbye
# #             image: registry.access.redhat.com/ubi8/ubi-minimal
# #             script: |
# #               #!/bin/sh
# #               echo "Goodbye from a minimal pipeline!"

# #     - name: conditionally-skipped-task
# #       runAfter:
# #         - goodbye
# #       when:
# #         - input: "false"
# #           operator: in
# #           values: ["true"]
# #       taskSpec:
# #         steps:
# #           - name: should-not-run
# #             image: registry.access.redhat.com/ubi8/ubi-minimal
# #             script: |
# #               echo "This task should be skipped!"

# #     - name: test-output
# #       runAfter:
# #         - conditionally-skipped-task
# #       taskSpec:
# #         results:
# #           - name: TEST_OUTPUT
# #         steps:
# #           - name: output-result
# #             image: registry.access.redhat.com/ubi8/ubi-minimal
# #             script: |
# #               #!/bin/sh
# #               echo '{"result": "SUCCESS"}' > $(results.TEST_OUTPUT.path)
# #     # - name: task-with-high-resource-requirements
# #     #   runAfter:
# #     #     - test-output
# #     #   taskSpec:
# #     #     steps:
# #     #       - name: run-with-high-memory
# #     #         image: busybox:latest
# #     #         script: |
# #     #           #!/bin/sh
# #     #           echo "Simulating high memory usage to exceed node resources"
# #     #           sleep 60
# #     - name: simulate-pending
# #       runAfter:
# #         # - task-with-high-resource-requirements
# #         - test-output
# #       taskSpec:
# #         steps:
# #           - name: wait-forever
# #             image: busybox:doesnotexist
# #             script: |
# #               #!/bin/sh
# #               echo "This should never run"
# #               sleep 9999
# #     - name: simulate-pending-2
# #       runAfter:
# #         # - simulate-pending
# #         - test-output
# #       taskSpec:
# #         podTemplate:
# #           spec:
# #             containers:
# #               - name: wait
# #                 image: busybox
# #                 volumeMounts:
# #                   - name: missing-volume
# #                     mountPath: /fake
# #                 resources:
# #                   requests:
# #                     memory: "100Gi" # Large memory request to force Pending state
# #                     cpu: "1000m" # High CPU request
# #                 script: |
# #                   #!/bin/sh
# #                   echo "Trying to simulate pending"
# #         volumes:
# #           - name: big-vol
# #             persistentVolumeClaim:
# #               claimName: does-not-exist
# #             # emptyDir:
# #             #   sizeLimit: "20Ti"
# #     # - name: task-with-no-existing-image
# #     #   runAfter:
# #     #     - test-output
# #     #   taskSpec:
# #     #     steps:
# #     #       - name: broken
# #     #         image: busybox:doesnotexist
# #     #         script: |
# #     #           echo "This will never run"

# #     # - name: no-op-output
# #     #   runAfter:
# #     #     - test-output
# #     #   taskSpec:
# #     #     steps:
# #     #       - name: no-op
# #     #         image: busybox:latest
# #     #         script: |
# #     #           tail -f /dev/null  # Wait forever until manually stopped

# #     # - name: test-output-simulate
# #     #   runAfter:
# #     #     - conditionally-skipped-task
# #     #   taskSpec:
# #     #     results:
# #     #       - name: TEST_OUTPUT
# #     #         description: "Test result output"
# #     #     steps:
# #     #       - name: simulate-error
# #     #         image: registry.access.redhat.com/ubi8/ubi-minimal
# #     #         script: |
# #     #           #!/bin/sh
# #     #           timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
# #     #           cat <<EOF > $(results.TEST_OUTPUT.path)
# #     #           {
# #     #             "result": "ERROR",
# #     #             "namespace": "example-namespace",
# #     #             "timestamp": "$timestamp",
# #     #             "successes": 0,
# #     #             "failures": 1,
# #     #             "warnings": 0,
# #     #             "note": "Simulated failure for testing TEST_OUTPUT reporting"
# #     #           }
# #     #           EOF
# #     #           exit 0
# #   finally:
# #     - name: long-finalizer
# #       taskSpec:
# #         steps:
# #           - name: final-cleanup
# #             image: registry.access.redhat.com/ubi8/ubi-minimal
# #             script: |
# #               #!/bin/sh
# #               echo "Starting long final task..."
# #               sleep 600  # Simulate long-running final step
# #               echo "Final task done."

# #   # - name: bad-final-task
# #   #   taskSpec:
# #   #     steps:
# #   #       - name: oops
# #   #         image: "nonexistent/image:latest" # This image doesn't exist
# #   #         script: |
# #   #           #!/bin/sh
# #   #           echo "This will never run"

# #   # - name: sneaky-final
# #   #   when:
# #   #     - input: "false"
# #   #       operator: in
# #   #       values: ["true"]
# #   #   taskSpec:
# #   #     steps:
# #   #       - name: sneaky-step
# #   #         image: registry.access.redhat.com/ubi8/ubi-minimal
# #   #         script: |
# #   #           #!/bin/sh
# #   #           echo "This should never run"

# #   # - name: idle-final-task
# #   #   taskRef:
# #   #     name: idle-final-task
# #   # finally:
# #   #   - name: idle-final-task
# #   #     when:
# #   #       - input: "$(params.enable-finalizer)"
# #   #         operator: in
# #   #         values: ["true"]
# #   #     params:
# #   #       - name: enable-finalizer
# #   #         value: "$(params.enable-finalizer)"
# #   #     taskRef:
# #   #       name: idle-final-task
# #   # taskRunTemplate:
# #   #   serviceAccountName: does-not-exist
# #   # finally:
# #   #   - name: wait-for-manual-finish
# #   #     params:
# #   #       - name: enable-wait
# #   #         value: "$(params.enable-finalizer)"
# #   #     taskSpec:
# #   #       params:
# #   #         - name: enable-wait
# #   #           type: string
# #   #       steps:
# #   #         - name: maybe-wait
# #   #           image: registry.access.redhat.com/ubi8/ubi-minimal
# #   #           script: |
# #   #             #!/bin/sh
# #   #             if [ "$(params.enable-wait)" = "true" ]; then
# #   #               echo "Finalizer enabled. Waiting forever..."
# #   #               tail -f /dev/null
# #   #             else
# #   #               echo "Finalizer disabled. Skipping wait."
# #   #             fi
# #   # finally:
# #   #   - name: task-with-no-existing-image
# #   #     taskSpec:
# #   #       steps:
# #   #         - name: maybe-broken
# #   #           image: busybox:doesnotexist
# #   #           script: |
# #   #             echo "This will never run"
# #   # finally:
# #   #   - name: pending-forever
# #   #     taskSpec:
# #   #       steps:
# #   #         - name: pending-simulator
# #   #           image: busybox
# #   #           script: |
# #   #             #!/bin/sh
# #   #             echo "Simulating pending state by waiting on a file that never appears..."
# #   #             while [ ! -f /tmp/continue ]; do
# #   #               sleep 10
# #   #             done
# apiVersion: tekton.dev/v1
# kind: Pipeline
# metadata:
#   name: simulate-long-running-time-release
#   annotations:
#     tekton.dev/tags: release
#   labels:
#     appstudio.openshift.io/release-pipeline: "true"
# spec:
#   description: Minimal pipeline for testing ReleasePlan integration
#   params:
#     - name: enable-finalizer
#       type: string
#       default: "true"
#     - name: enable-wait
#       type: string
#       default: "true"
#   workspaces:
#     - name: release-workspace
#   # results:
#   #   - name: TEST_OUTPUT
#   #     value: "$(tasks.test-output.results.TEST_OUTPUT)"
#   tasks:
#     - name: hello
#       taskSpec:
#         steps:
#           - name: say-hello
#             image: registry.access.redhat.com/ubi8/ubi-minimal
#             script: |
#               #!/bin/sh
#               echo "Hello from a minimal pipeline!"

#     - name: goodbye
#       runAfter:
#         - hello
#       taskSpec:
#         steps:
#           - name: say-goodbye
#             image: registry.access.redhat.com/ubi8/ubi-minimal
#             script: |
#               #!/bin/sh
#               echo "Goodbye from a minimal pipeline!"

#     # - name: simulate-pending
#     #   runAfter:
#     #     - goodbye
#     #   taskSpec:
#     #     steps:
#     #       - name: simulate
#     #         image: busybox
#     #         command: ["sh"]
#     #         args: ["-c", "echo 'This should never run'"]
#     #         volumeMounts:
#     #           - name: missing-volume
#     #             mountPath: /not-there
#     #     volumes:
#     #       - name: missing-volume
#     #         persistentVolumeClaim:
#     #           claimName: pvc-that-does-not-exist
#   # finally:
#   #   - name: long-finalizer
#   #     taskSpec:
#   #       steps:
#   #         - name: final-cleanup
#   #           image: "nonexistent-registry.example.com/fake-image:latest"
#   #           script: |
#   #             #!/bin/sh
#   #             echo "Trying to run an unavailable image"
#   # finally:
#   #   - name: simulate-pending-finally
#   #     taskSpec:
#   #       steps:
#   #         - name: pending-volume
#   #           image: busybox
#   #           script: |
#   #             #!/bin/sh
#   #             echo "This should never run"
#   #           volumeMounts:
#   #             - name: missing-volume
#   #               mountPath: /not-there
#   #       volumes:
#   #         - name: missing-volume
#   #           persistentVolumeClaim:
#   #             claimName: pvc-does-not-exist
#   finally:
#     - name: delay
#       taskSpec:
#         steps:
#           - name: wait
#             image: busybox
#             script: |
#               #!/bin/sh
#               echo "Sleeping..."
#               sleep 9999
apiVersion: tekton.dev/v1
kind: Pipeline
metadata:
  name: simulate-long-running-pipeline
  # spec:
  # tasks:
  #   - name: task-1
  #     taskSpec:
  #       steps:
  #         - name: say-hello
  #           image: registry.access.redhat.com/ubi8/ubi-minimal
  #           script: |
  #             #!/bin/sh
  #             echo "Hello from Task 1"
  #   - name: task-2
  #     taskSpec:
  #       steps:
  #         - name: say-goodbye
  #           image: registry.access.redhat.com/ubi8/ubi-minimal
  #           script: |
  #             #!/bin/sh
  #             echo "Goodbye from Task 2"
  # finally:
  #   - name: task-3
  #     taskSpec:
  #       steps:
  #         - name: wait-forever
  #           image: busybox
  #           script: |
  #             #!/bin/sh
  #             echo "Task 3 is running indefinitely"
  #             sleep 9999999  # Simulate a long-running task
# spec:
#   params:
#     - name: run-final-task
#       type: string
#       default: "yes"
#   tasks:
#     - name: long-running-task
#       taskSpec:
#         steps:
#           - name: sleep
#             image: alpine
#             script: |
#               echo "Sleeping forever..."
#               sleep 999999

#     - name: final-task
#       # runAfter:
#       #   - long-running-task # To test, you could remove this dependency to break normal flow
#       when:
#         - input: "$(params.run-final-task)"
#           operator: in
#           values: ["yes"]
#       taskSpec:
#         steps:
#           - name: finish
#             image: alpine
#             script: |
#               echo "Finishing quickly"
#   finally:
#     - name: fast-finish
#       taskSpec:
#         steps:
#           - name: finish
#             image: alpine
#             script: |
#               echo "Finished"
# spec:
#   params:
#     - name: run-quick-task
#       type: string
#       default: "yes"

#   tasks:
#     - name: long-task-a
#       taskSpec:
#         steps:
#           - name: sleep-a
#             image: alpine
#             script: |
#               echo "Simulating long task A"
#               sleep 999999

#     - name: long-task-b
#       taskSpec:
#         steps:
#           - name: sleep-b
#             image: alpine
#             script: |
#               echo "Simulating long task B"
#               sleep 999999

#     - name: quick-conditional-task
#       when:
#         - input: "$(params.run-quick-task)"
#           operator: in
#           values: ["yes"]
#       taskSpec:
#         steps:
#           - name: quick
#             image: alpine
#             script: |
#               echo "Quick conditional task completed."

#   finally:
#     - name: report
#       taskSpec:
#         steps:
#           - name: report
#             image: alpine
#             script: |
#               echo "Finally block executed."
# spec:
#   params:
#     - name: skip-something
#       type: string
#       default: "no"

#   tasks:
#     - name: long-runner
#       taskSpec:
#         steps:
#           - name: sleep
#             image: alpine
#             script: |
#               echo "Long-running task"
#               sleep 999999

#     - name: retrying-task
#       retries: 2
#       taskSpec:
#         steps:
#           - name: maybe-fail
#             image: alpine
#             script: |
#               if [ "$(RETRY_COUNT)" == "1" ]; then
#                 echo "Failing on first try"
#                 exit 1
#               fi
#               echo "Succeeded on retry"
#             env:
#               - name: RETRY_COUNT
#                 valueFrom:
#                   fieldRef:
#                     fieldPath: metadata.annotations['tekton.dev/retry-count']

#     - name: skipped-task
#       when:
#         - input: "$(params.skip-something)"
#           operator: in
#           values: ["yes"]
#       taskSpec:
#         steps:
#           - name: should-skip
#             image: alpine
#             script: |
#               echo "This should be skipped"

#   finally:
#     - name: final-cleanup
#       taskSpec:
#         steps:
#           - name: clean
#             image: alpine
#             script: |
#               echo "Cleaning up pipeline"
# spec:
#   params:
#     - name: run-long
#       type: string
#       default: "no"

#   tasks:
#     - name: matrix-fast-tasks
#       matrix:
#         params:
#           - name: mode
#             value: ["fast1", "fast2"]
#       taskSpec:
#         params:
#           - name: mode
#             type: string
#         steps:
#           - name: run-fast
#             image: alpine
#             script: |
#               echo "Running mode $(params.mode)..."
#               sleep 1

#     - name: long-runner
#       when:
#         - input: "$(params.run-long)"
#           operator: in
#           values: ["yes"]
#       taskSpec:
#         steps:
#           - name: hang
#             image: alpine
#             script: |
#               echo "This task will hang forever..."
#               sleep 999999

#   finally:
#     - name: final-step
#       taskSpec:
#         steps:
#           - name: done
#             image: alpine
#             script: |
#               echo "Final cleanup complete."
# spec:
#   params:
#     - name: run-failing-iteration
#       type: string
#       default: "yes"
#   tasks:
#     - name: matrix-task
#       matrix:
#         params:
#           - name: iteration
#             value: ["1", "2"]
#       taskSpec:
#         params:
#           - name: iteration
#             type: string
#         steps:
#           - name: run
#             image: alpine
#             script: |
#               echo "Running iteration $(params.iteration)"
#               if [ "$(params.iteration)" = "2" ]; then
#                 echo "Simulating failure on iteration 2"
#                 exit 1
#               fi
#               echo "Success on iteration $(params.iteration)"

#     - name: conditional-skipped-task
#       when:
#         - input: "$(params.run-failing-iteration)"
#           operator: notin
#           values: ["yes"]
#       taskSpec:
#         steps:
#           - name: skipped
#             image: alpine
#             script: echo "Should be skipped"

#   finally:
#     - name: cleanup
#       taskSpec:
#         steps:
#           - name: cleanup-step
#             image: alpine
#             script: echo "Final cleanup runs no matter what"
# spec:
#   params:
#     - name: run-failing-iteration
#       type: string
#       default: "yes"
#   tasks:
#     - name: matrix-task
#       matrix:
#         params:
#           - name: iteration
#             value: ["1", "2"]
#       taskSpec:
#         params:
#           - name: iteration
#             type: string
#         steps:
#           - name: run
#             image: alpine
#             script: |
#               echo "Running iteration $(params.iteration)"
#               if [ "$(params.iteration)" = "2" ]; then
#                 echo "Simulating failure on iteration 2"
#                 exit 0  # Pretend success even on failure
#               fi
#               echo "Success on iteration $(params.iteration)"

#     - name: conditional-skipped-task
#       when:
#         - input: "$(params.run-failing-iteration)"
#           operator: notin
#           values: ["yes"]
#       taskSpec:
#         steps:
#           - name: skipped
#             image: alpine
#             script: echo "Should be skipped"

#   finally:
#     - name: cleanup
#       taskSpec:
#         steps:
#           - name: cleanup-step
#             image: alpine
#             script: echo "Final cleanup runs no matter what"
# spec:
#   params:
#     - name: matrix-entries
#       type: array
#       default: ["fast", "stuck"]
#   tasks:
#     - name: matrix-task
#       matrix:
#         params:
#           - name: entry
#             value: ["fast", "stuck"]
#       taskSpec:
#         params:
#           - name: entry
#             type: string
#         steps:
#           - name: simulate
#             image: alpine
#             script: |
#               if [ "$(params.entry)" = "fast" ]; then
#                 echo "Fast task completes quickly"
#                 exit 0
#               elif [ "$(params.entry)" = "stuck" ]; then
#                 echo "Stuck task simulates pending..."
#                 # Try using nonexistent volume to make it stay in Pending
#                 mkdir -p /nonexistent/path
#                 touch /nonexistent/path/will-not-work
#               fi

#     - name: final-step
#       runAfter:
#         - matrix-task
#       taskSpec:
#         steps:
#           - name: done
#             image: alpine
#             script: echo "Final step complete"
# spec:
#   tasks:
#     - name: matrix-task
#       matrix:
#         params:
#           - name: variant
#             value: ["good", "nosuchregistry.example.com/fake/image"]
#       taskSpec:
#         params:
#           - name: variant
#             type: string
#         steps:
#           - name: check
#             image: $(params.variant)
#             script: |
#               echo "This should run for variant: $(params.variant)"

#     - name: finalizer
#       runAfter: [matrix-task]
#       taskSpec:
#         steps:
#           - name: finish
#             image: alpine
#             script: |
#               echo "Pipeline finished"
spec:
  params:
    - name: should-run-bad-task
      type: string
      default: "no"

  tasks:
    - name: good-task
      taskSpec:
        steps:
          - name: do-good
            image: alpine
            script: |
              echo "This task completes successfully."

    - name: bad-task
      when:
        - input: "$(params.should-run-bad-task)"
          operator: in
          values: ["yes"]
      taskSpec:
        steps:
          - name: hang
            image: nosuchregistry.example.com/never:pull
            script: |
              echo "Should never get here."

    - name: final-step
      runAfter: [good-task]
      taskSpec:
        steps:
          - name: finalize
            image: alpine
            script: |
              echo "All done."
